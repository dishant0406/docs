---
title: "Core Concepts"
description: "Fundamental principles of agent runtime observability"
---

# Core Concepts

Understanding WhyOps requires grasping a few key concepts that differentiate agent observability from traditional monitoring.

## Agent Runtime Observability (ARO)

<Note>
**Agent Runtime Observability** is the practice of capturing and analyzing the cognitive state and decision-making process of autonomous AI systems.
</Note>

Unlike traditional observability which focuses on **what happened**, ARO focuses on **why it happened**.

### The Observability Hierarchy

```
Traditional Monitoring
    ↓
APM (Application Performance Monitoring)
    ↓
Distributed Tracing
    ↓
LLM Observability
    ↓
✨ Agent Runtime Observability ← WhyOps
```

Each layer builds on the previous, adding deeper context and understanding.

## Decision Infrastructure

WhyOps provides **Decision Infrastructure for Agents** - a new category in the AI stack.

<CardGroup cols={2}>
  <Card title="What It Is" icon="layer-group">
    Infrastructure that captures, stores, and reconstructs the decision-making state of AI agents
  </Card>
  
  <Card title="What It Enables" icon="key">
    Debugging, auditing, optimizing, and governing autonomous AI systems
  </Card>
</CardGroup>

### Where It Fits

```
┌──────────────────────────────────────┐
│ Application Layer                    │
│ (Your Agent Application)             │
├──────────────────────────────────────┤
│ WhyOps - Decision Infrastructure     │ ← Interprets decisions
├──────────────────────────────────────┤
│ Agent Framework                      │
│ (LangChain, CrewAI, AutoGen)         │
├──────────────────────────────────────┤
│ LLM Provider                         │
│ (OpenAI, Anthropic, etc.)            │
└──────────────────────────────────────┘
```

## Cognitive Trace vs. Execution Trace

Understanding the difference is crucial:

| Execution Trace | Cognitive Trace |
|----------------|-----------------|
| API calls made | Decisions made |
| Responses received | Reasoning captured |
| Timing data | Context tracked |
| Error codes | Decision causality |
| Linear logs | Decision graph |

<Tip>
**Execution trace** tells you what ran. **Cognitive trace** tells you why it ran that way.
</Tip>

## The Four Cognitive Boundaries

WhyOps operates at four key decision points in every agent:

<Steps>
  <Step title="Planner Step">
    **What:** Agent decides next action
    
    **Captures:** Strategy, confidence, state evolution
    
    **Example:** "Retry with backoff because last tool timed out"
  </Step>
  
  <Step title="Memory Retrieval">
    **What:** Past information influences decision
    
    **Captures:** Retrieved candidates, similarity scores, filters applied
    
    **Example:** "Used top 4 docs with score > 0.78, dropped 16 others"
  </Step>
  
  <Step title="LLM Reasoning">
    **What:** Model generates thoughts and actions
    
    **Captures:** Full prompts, tools available, responses
    
    **Example:** Standard LLM observability (everyone does this)
  </Step>
  
  <Step title="Tool Execution">
    **What:** External world interaction
    
    **Captures:** I/O, errors, retries, latency, sanitization
    
    **Example:** "Tool failed twice, succeeded on attempt 3"
  </Step>
</Steps>

<Info>
These four boundaries form a **complete cognitive loop** - capture all four, and you can reconstruct any agent decision.
</Info>

## State Reproducibility

One of WhyOps's most powerful concepts: **every agent state is reproducible**.

### What This Means

If you can capture:
1. The exact prompt state
2. The memory context
3. The tool definitions
4. The framework configuration
5. The execution history

Then you can **replay** any production failure in your dev environment.

<Card title="The Reproducibility Principle" icon="repeat">
  "If you can't reproduce it, you can't fix it" - now applies to AI agents
</Card>

### How It Works

```python
# Production agent fails
production_state = whyops.capture_state(thread_id="prod_abc123")

# Replay in dev
dev_replay = whyops.replay(
    state=production_state,
    environment="development"
)

# Now you can debug with full context
```

## LLM Cognition vs. Runtime Cognition

<Warning>
**Critical Distinction:** Not all agent decisions happen in the LLM.
</Warning>

### LLM Cognition

What the model sees and reasons about:
- Prompts
- Context provided
- Tool definitions
- Previous messages

**Visible to:** Proxy-based observability ✅

### Runtime Cognition

What the framework decides:
- When to retry tools
- Which memories to retrieve
- When to terminate execution
- How to sanitize errors
- Which context to include

**Visible to:** Only SDK-based observability ⚠️

### The Gap

```
Agent Decision = LLM Cognition + Runtime Cognition

Current Tools See:  ████████░░░░░░░░░░ (40%)
WhyOps Sees:       ████████████████████ (100%)
```

## Event-Driven Architecture

WhyOps uses an event-driven model to capture agent cognition:

```
Agent Execution
    ↓
    ├── LLM Call Event
    ├── Tool Execution Event  
    ├── Memory Retrieval Event
    ├── Planner State Event
    └── Termination Event
    ↓
WhyOps Event Stream
    ↓
Decision Graph Construction
```

Each event is:
- **Timestamped** - when it occurred
- **Thread-linked** - which agent session
- **Context-enriched** - full decision context
- **Causally-linked** - connections to other events

## Decision Causality

WhyOps builds a **causality graph** linking events to decisions:

```
Memory Retrieval: [doc_A, doc_B, doc_C]
    ↓ influenced
LLM Call: "Given these policies..."
    ↓ resulted in
Tool Call: search_economics("policy impact")
    ↓ produced
Tool Result: [economic data]
    ↓ influenced
LLM Call: "Based on economic data..."
    ↓ resulted in
Final Answer
```

<Tip>
This graph answers: **"What context led to this specific decision?"**
</Tip>

## Framework Agnostic Design

WhyOps doesn't wrap frameworks - it wraps **decision boundaries**.

### Why This Matters

```
❌ Bad Approach:
- Build LangChain adapter
- Build CrewAI adapter  
- Build AutoGen adapter
- Maintain 20+ adapters

✅ WhyOps Approach:
- Wrap LLM calls (universal)
- Wrap function execution (universal)
- Wrap decision events (universal)
```

<Card title="Result" icon="universal-access">
  Works with any framework, including custom ones. No framework-specific code needed.
</Card>

## Progressive Enhancement

WhyOps provides value at multiple levels:

<Steps>
  <Step title="Level 1: Proxy Only">
    **Coverage:** 70-80%
    
    **Effort:** Minimal (URL change)
    
    **Captures:** LLM calls, basic tool tracking
  </Step>
  
  <Step title="Level 2: SDK Integration">
    **Coverage:** 95%+
    
    **Effort:** Medium (decorators)
    
    **Captures:** Full runtime cognition
  </Step>
  
  <Step title="Level 3: Advanced Hooks">
    **Coverage:** 99%+
    
    **Effort:** High (custom instrumentation)
    
    **Captures:** Deep framework integration
  </Step>
</Steps>

You get value immediately, with the option to go deeper.

## Thread Context

Every agent interaction is a **thread** - a single cognitive session.

### Thread Properties

```json
{
  "thread_id": "t_abc123",
  "created_at": "2026-01-28T10:00:00Z",
  "agent_type": "research_assistant",
  "events": [
    // All events for this session
  ],
  "state_snapshots": [
    // State at key decision points
  ]
}
```

<Note>
Think of threads like user sessions - they group related agent activity and enable replay.
</Note>

## Key Takeaways

<AccordionGroup>
  <Accordion title="1. ARO is a new category" icon="1">
    Agent Runtime Observability is distinct from LLM observability or APM
  </Accordion>
  
  <Accordion title="2. Two types of cognition" icon="2">
    LLM cognition (visible to proxy) and runtime cognition (needs SDK)
  </Accordion>
  
  <Accordion title="3. Four cognitive boundaries" icon="3">
    Planner, Memory, LLM, and Tool execution form a complete loop
  </Accordion>
  
  <Accordion title="4. State is reproducible" icon="4">
    Captured state can be replayed for debugging
  </Accordion>
  
  <Accordion title="5. Framework agnostic" icon="5">
    Works by wrapping decision boundaries, not frameworks
  </Accordion>
</AccordionGroup>

---

<Info>
**Next:** See how to get started with the [Quick Start Guide](/quickstart)
</Info>